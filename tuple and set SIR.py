#Today's Topic is tuple and Set.#tuple ------() same as list but it is immutable in nature.#It also contain heterog. elements.It also support indexing and slicing."""v = ()print("v==",v,type(v),"len==",len(v),id(v))v1 = tuple()   #function callingprint("v1==",v1,type(v1),"len==",len(v1))#print("dir======",dir(v))v3 = (1,2,3)print("v3====",v3)print(v3[0])  #it is not allowed in the tuple due to immutable in nature."""v5  = (1,2.3,"sdbjfk",True,5+13j,5e3,[21,32.3,458,("AsfdA",125,56.6,78),"end"],{1,1,2,3,50,45,False}#set       ,       {"A":15,1:15,"asd":456,265.5:"sdfsdf"},"End",2.3,1)print("v5==",v5,type(v5),"len==",len(v5),id(v5))print("Indexing=====",v5[0])print("Indexing=====",v5[-1])print("Indexing=====",v5[-2])print("Indexing=====",v5[-5])print(type(v5[-5]))print(v5[-5].update("80"))print("Indexing=====",v5[4])print("Indexing=====",v5[3])#print("Indexing=====",v5[13])  #IndexError: tuple index out of rangeprint("Slicing===1==",v5[1: 35:2])print("Slicing=====",v5[11: 3:2])  #return .....silicing doest not go backwardprint("Slicing=====",v5[2:-1])op2 = v5.index(2.3)print("op2======",op2)op3= v5.count(1)print("op3====",op3)print("sizeoff=====",v5.__sizeof__())"""#=====================SET=====================================##set --> it is unordered  and unique collection of hetrogenous element.#Set is mutable in nature. And set does not support indexing and slicing...#Due to unordered behaviour set not support indexing and slicing...#frozen set act like a immutable set.s = set()print("s===",s,type(s),"address====",id(s),"len==",len(s))s1 = {1}print("s1===-------",s1,type(s1),"address====",id(s1),"len==",len(s1))#Now insert data into set--------------s2 = {1,2,3,5.5,True,False,"Adfadf",      5e3,5+3j,32,"nishant",78,78.3333,"ASfaf",1,2,3,4,5,5.5,True,65+32j,15,38.5,32,78,95,78,      "ASfaf",1,2,3,4,5,5.5,True,      ("nishant",78,78.3333,65+32j)}print("s2===-------",s2,type(s2),"address====",id(s2),"len==",len(s2))#All utility methods related to set......#print("dir=====",dir(s))s3 = {1,2,3,5.5,"bcjaafaf","sdf",12,5e-3,True,False,"Adfadf",5e3,5+3j,32,"nishant"}print(" s3==",s3,"address====",id(s3),"len==",len(s3))#add======here ,ity is use to add data in the existing set.op1 = s2.add(10)    #add any element in setprint("op1====",op1)   #no return typeop2 = s2.add((1000,10000,12000))    #add any element in setprint("op2====",op2)   #no return typeprint("After adding element in set then set is s2==",s2,"address====",id(s2),"len==",len(s2))#use to remove data with pattern matching-------remove take data and  delete it from current setop3 = s2.remove("nishant")  #remove has no returntypeprint("op3 remove===",op3)    #keyerror when data not present.print("Afterremoving element in set then set is s2==",s2,"address====",id(s2),"len==",len(s2))#pop=========it is use to remove data from set...op4 = s2.pop()  #its has return type.op5 = s2.pop()op6 = s2.pop()op41 = s2.pop()op51= s2.pop()op61 = s2.pop()print("op4===pop1=====",op4)print("op5===pop2======",op5)print("op6===pop3====",op6)print("op41===pop4=====",op41)print("op51===pop5======",op51)print("op61===pop6====",op61)print("__doc__",s2.__doc__)   #it provide documentationprint("s2===== __sizeof__",s2.__sizeof__())  #itr provide memory sizeprint("s3===== __sizeof__",s3.__sizeof__())#-----------------------------INTERSECTION----------------------------------------------op7 = s2.intersection(s3)   #it contain only common elements from s3 and s2print("Op7 intersection=====",op7)op8 = s3.intersection(s2)   print("Op8 intersection=====",op8)#if we perfrom intersection we also use &op9 = s2&s3op10 = s3 & s2print("op9==============",op9)print("op10==============",op10)#--------------------------UNION---------------------------------------------#accept both set and make one large set from all elements present in both but always accept unique elementop11 = s3.union(s2)op12 = s2.union(s3)op13 = s3 | s2op14 = s2|s3print("Union op11====",op11)print("Union op12====",op12)print("Union op13====",op13)print("Union op14====",op14)#difference--------------op15 = s3 - s2    #always discard common element and return unique once  op151 = s3.difference(s2)op16  = s2-s3op161 = s2.difference(s3)print("diff====op15===",op15)print("diff====op151==",op151)#print("diff====op16===",op16)#print("diff====op161==",op161)#subsetop17  = s2.issubset(s3)op171 = s.issubset(s3)op172 = s3.issubset(op12)print("is subset====",op17)print("is subset====",op171)print("is subset with union set===",op172)ss = s2#superset---op18 = s2.issuperset(op13)print("isSuperset==",op18 )op181 = ss.issuperset(s2)print("isSuperset==",op181 )...............FROZEN SET........s2 = {1,2,3,5.5,True,False,"Adfadf",      5e3,5+3j,32,"nishant",78,78.3333,"ASfaf",1,2,3,4,5,5.5,True,65+32j,15,38.5,32,78,95,78,      "ASfaf",1,2,3,4,5,5.5,True,      ("nishant",78,78.3333,65+32j)}s3=s2.add(25)print(s3)print(s2)s4=frozenset(s2)print(s2)s5=s4.add(90)print(s2)"""